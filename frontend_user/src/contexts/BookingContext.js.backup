import React, { createContext, useState, useContext } from 'react';

// T·∫°o context
export const BookingContext = createContext();

// Data m·∫´u cho seat map
const sampleSeats = {
  "hot-desk": [
    { id: "A1", name: "A1", available: true, type: "hot-desk" },
    { id: "A2", name: "A2", available: false, type: "hot-desk" },
    { id: "A3", name: "A3", available: true, type: "hot-desk" },
    { id: "A4", name: "A4", available: true, type: "hot-desk" },
    { id: "A5", name: "A5", available: true, type: "hot-desk" },
    { id: "A6", name: "A6", available: false, type: "hot-desk" },
    { id: "A7", name: "A7", available: true, type: "hot-desk" },
    { id: "A8", name: "A8", available: true, type: "hot-desk" },
    { id: "B1", name: "B1", available: false, type: "hot-desk" },
    { id: "B2", name: "B2", available: true, type: "hot-desk" },
    { id: "B3", name: "B3", available: false, type: "hot-desk" },
    { id: "B4", name: "B4", available: true, type: "hot-desk" },
    { id: "B5", name: "B5", available: true, type: "hot-desk" },
    { id: "B6", name: "B6", available: false, type: "hot-desk" },
    { id: "B7", name: "B7", available: true, type: "hot-desk" },
    { id: "B8", name: "B8", available: false, type: "hot-desk" },
    { id: "C1", name: "C1", available: true, type: "hot-desk" },
    { id: "C2", name: "C2", available: true, type: "hot-desk" },
    { id: "C3", name: "C3", available: false, type: "hot-desk" },
    { id: "C4", name: "C4", available: true, type: "hot-desk" },
    { id: "C5", name: "C5", available: false, type: "hot-desk" },
    { id: "C6", name: "C6", available: true, type: "hot-desk" },
    { id: "C7", name: "C7", available: true, type: "hot-desk" },
    { id: "C8", name: "C8", available: false, type: "hot-desk" },
    { id: "D1", name: "D1", available: true, type: "hot-desk" },
    { id: "D2", name: "D2", available: false, type: "hot-desk" },
    { id: "D3", name: "D3", available: true, type: "hot-desk" },
    { id: "D4", name: "D4", available: false, type: "hot-desk" },
    { id: "D5", name: "D5", available: true, type: "hot-desk" },
    { id: "D6", name: "D6", available: true, type: "hot-desk" },
    { id: "D7", name: "D7", available: false, type: "hot-desk" },
    { id: "D8", name: "D8", available: true, type: "hot-desk" }
  ],
  "fixed-desk": [
    { id: "A1-F", name: "A1", available: false, type: "fixed-desk" },
    { id: "A2-F", name: "A2", available: true, type: "fixed-desk" },
    { id: "A3-F", name: "A3", available: true, type: "fixed-desk" },
    { id: "A4-F", name: "A4", available: false, type: "fixed-desk" },
    { id: "A5-F", name: "A5", available: true, type: "fixed-desk" },
    { id: "A6-F", name: "A6", available: true, type: "fixed-desk" },
    { id: "A7-F", name: "A7", available: false, type: "fixed-desk" },
    { id: "A8-F", name: "A8", available: true, type: "fixed-desk" },
    { id: "B1-F", name: "B1", available: true, type: "fixed-desk" },
    { id: "B2-F", name: "B2", available: true, type: "fixed-desk" },
    { id: "B3-F", name: "B3", available: false, type: "fixed-desk" },
    { id: "B4-F", name: "B4", available: true, type: "fixed-desk" },
    { id: "B5-F", name: "B5", available: false, type: "fixed-desk" },
    { id: "B6-F", name: "B6", available: true, type: "fixed-desk" },
    { id: "B7-F", name: "B7", available: true, type: "fixed-desk" },
    { id: "B8-F", name: "B8", available: false, type: "fixed-desk" },
    { id: "C1-F", name: "C1", available: true, type: "fixed-desk" },
    { id: "C2-F", name: "C2", available: false, type: "fixed-desk" },
    { id: "C3-F", name: "C3", available: true, type: "fixed-desk" },
    { id: "C4-F", name: "C4", available: true, type: "fixed-desk" },
    { id: "C5-F", name: "C5", available: false, type: "fixed-desk" },
    { id: "C6-F", name: "C6", available: true, type: "fixed-desk" },
    { id: "C7-F", name: "C7", available: false, type: "fixed-desk" },
    { id: "C8-F", name: "C8", available: true, type: "fixed-desk" },
    { id: "D1-F", name: "D1", available: false, type: "fixed-desk" },
    { id: "D2-F", name: "D2", available: true, type: "fixed-desk" },
    { id: "D3-F", name: "D3", available: true, type: "fixed-desk" },
    { id: "D4-F", name: "D4", available: false, type: "fixed-desk" },
    { id: "D5-F", name: "D5", available: true, type: "fixed-desk" },
    { id: "D6-F", name: "D6", available: false, type: "fixed-desk" },
    { id: "D7-F", name: "D7", available: true, type: "fixed-desk" },
    { id: "D8-F", name: "D8", available: true, type: "fixed-desk" }
  ]
};

export const BookingProvider = ({ children }) => {
  // State qu·∫£n l√Ω c√°c b∆∞·ªõc booking
  const [bookingState, setBookingState] = useState({
    // B∆∞·ªõc 1: Ch·ªçn lo·∫°i d·ªãch v·ª•
    serviceType: null, // 'hot-desk' ho·∫∑c 'fixed-desk'
    
    // B∆∞·ªõc 2: Ch·ªçn g√≥i th·ªùi gian
    packageDuration: null, // 'daily', 'weekly', 'monthly', 'yearly'
    
    // B∆∞·ªõc 3: Ch·ªçn ng√†y v√† gi·ªù
    date: null,
    endDate: null, // Th√™m ng√†y k·∫øt th√∫c d·ª±a v√†o package duration
    time: null, // Th√™m gi·ªù b·∫Øt ƒë·∫ßu ri√™ng
    endTime: null, // Th√™m gi·ªù k·∫øt th√∫c ri√™ng
    
    // B∆∞·ªõc 4: Ch·ªçn v·ªã tr√≠ ch·ªó ng·ªìi
    selectedSeat: null,
    
    // B∆∞·ªõc 5: Thanh to√°n
    paymentMethod: null, // 'credit-card', 'bank-transfer', 'momo', etc.
    bookingComplete: false,
    
    // L∆∞u tr·ªØ d·ªØ li·ªáu ch·ªó ng·ªìi
    seats: sampleSeats,
    
    // Th√¥ng tin thanh to√°n
    paymentDetails: {
      totalAmount: 0,
      discount: 0,
      finalAmount: 0
    },
    // Danh s√°ch packages l·∫•y t·ª´ BE (hot_desk + fixed_desk)
    packages: [],         // raw list t·ª´ API (bao g·ªìm final_price, discount_pct)
    packagesLoaded: false,
    selectedPackageId: null  // id g√≥i c·ª• th·ªÉ (k·∫øt h·ª£p v·ªõi packageDuration tr∆∞·ªõc ƒë√¢y)
  });

  // L∆∞u tr·ªØ b∆∞·ªõc hi·ªán t·∫°i
  const [currentStep, setCurrentStep] = useState(1);

  // State ƒë·ªÉ l∆∞u tr·ªØ occupied seats
  const [occupiedSeats, setOccupiedSeats] = useState([]);
  const [loading, setLoading] = useState(false);

  // Ph∆∞∆°ng th·ª©c c·∫≠p nh·∫≠t service type (B∆∞·ªõc 1)
  async function fetchPackagesIfNeeded() {
    if (bookingState.packagesLoaded) return;
    try {
      const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';
      const resp = await fetch(`${apiUrl}/api/packages`);
      if (!resp.ok) throw new Error('Fetch packages failed');
      const data = await resp.json();
      // Ch·ªâ l·∫•y active + hot_desk/fixed_desk
      const filtered = data.filter(p => ['hot_desk','fixed_desk'].includes(p.service_code) && p.status === 'active');
      setBookingState(prev => ({ ...prev, packages: filtered, packagesLoaded: true }));
    } catch (e) {
      console.error('L·ªói t·∫£i packages:', e);
    }
  }

  const selectServiceType = async (type) => {
    // T·∫£i packages n·∫øu ch∆∞a c√≥
    await fetchPackagesIfNeeded();
    setBookingState(prev => ({
      ...prev,
      serviceType: type,
      // reset c√°c b∆∞·ªõc li√™n quan
      packageDuration: null,
      selectedPackageId: null,
      date: null,
      selectedSeat: null,
      paymentMethod: null,
      bookingComplete: false,
      // Gi·ªØ nguy√™n paymentDetails; s·∫Ω c·∫≠p nh·∫≠t khi ch·ªçn g√≥i c·ª• th·ªÉ
    }));
    setCurrentStep(2);
  };

  // Ph∆∞∆°ng th·ª©c c·∫≠p nh·∫≠t package duration (B∆∞·ªõc 2)
  const selectPackageDuration = (packageId) => {
    // ·ªû phi√™n b·∫£n m·ªõi: packageId ch√≠nh l√† ID g√≥i trong b·∫£ng service_packages
    const pkg = bookingState.packages.find(p => String(p.id) === String(packageId));
    if (!pkg) {
      console.warn('Package kh√¥ng t√¨m th·∫•y:', packageId);
      return;
    }
    const price = Number(pkg.price);
    const pct = Number(pkg.discount_pct || 0);
    const discountAmount = Math.round(price * pct / 100);
    const finalAmount = price - discountAmount;
    setBookingState(prev => ({
      ...prev,
      packageDuration: packageId, // gi·ªØ t√™n field c≈© ƒë·ªÉ kh√¥ng ph√° v·ª° code kh√°c
      selectedPackageId: packageId,
      date: null,
      selectedSeat: null,
      paymentMethod: null,
      bookingComplete: false,
      paymentDetails: {
        totalAmount: price,
        discount: discountAmount,
        finalAmount
      }
    }));
    setCurrentStep(3);
  };

  // Ph∆∞∆°ng th·ª©c c·∫≠p nh·∫≠t ng√†y (B∆∞·ªõc 3)
  const selectDate = (date, endDate, time, endTime) => {
    setBookingState({
      ...bookingState,
      date,
      endDate,
      time,
      endTime,
      // Reset c√°c b∆∞·ªõc ti·∫øp theo n·∫øu thay ƒë·ªïi ng√†y
      selectedSeat: null,
      paymentMethod: null,
      bookingComplete: false
    });
    setCurrentStep(4); // Chuy·ªÉn sang b∆∞·ªõc 4
  };

  // Ph∆∞∆°ng th·ª©c c·∫≠p nh·∫≠t ch·ªó ng·ªìi (B∆∞·ªõc 4)
  const selectSeat = (seat) => {
    setBookingState({
      ...bookingState,
      selectedSeat: seat,
      paymentMethod: null,
      bookingComplete: false
    });
    setCurrentStep(5); // Chuy·ªÉn sang b∆∞·ªõc 5 - Thanh to√°n
  };

  // Ph∆∞∆°ng th·ª©c ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n (B∆∞·ªõc 5)
  const selectPaymentMethod = (method) => {
    setBookingState({
      ...bookingState,
      paymentMethod: method
    });
  };

  // Ph∆∞∆°ng th·ª©c x√°c nh·∫≠n thanh to√°n v√† ho√†n t·∫•t ƒë·∫∑t ch·ªó (B∆∞·ªõc 5)
  const confirmBooking = async (paymentInfo = null) => {
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('No authentication token found. Please log in first.');
      }

      console.log('üîÑ Creating booking...', bookingState);
      console.log('üîÑ Payment info:', paymentInfo);

      const bookingData = {
        serviceType: bookingState.serviceType,
        packageDuration: bookingState.packageDuration,
        startDate: bookingState.date,
        startTime: bookingState.time,
        seatId: bookingState.selectedSeat ? bookingState.selectedSeat.id : null,
        seatName: bookingState.selectedSeat ? bookingState.selectedSeat.name : 'Hot Desk',
        floor: 1,
        specialRequests: 'Booking from frontend',
        basePrice: bookingState.paymentDetails.totalAmount,
        discountPercentage: bookingState.paymentDetails.discount > 0 ? 
          (bookingState.paymentDetails.discount / bookingState.paymentDetails.totalAmount * 100) : 0,
        finalPrice: bookingState.paymentDetails.finalAmount
      };

      console.log('ÔøΩ Booking data to send:', bookingData);

      const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';
      const response = await fetch(`${apiUrl}/api/bookings`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(bookingData)
      });

      const result = await response.json();
      
      console.log('üìä Booking API response:', result);
      
      if (result.success) {
        console.log('‚úÖ Booking created successfully:', result.booking);
        console.log('üí∞ Payment auto-created by backend');
        
        setBookingState({
          ...bookingState,
          bookingComplete: true,
          bookingReference: result.booking.bookingReference || result.booking.booking_reference,
          bookingId: result.booking.id
        });

        // Refresh occupied seats after successful booking
        setTimeout(() => {
          fetchOccupiedSeats(
            bookingState.serviceType,
            bookingState.date,
            bookingState.time,
            bookingState.endTime
          );
        }, 1000);

        return { success: true, booking: result.booking };
      } else {
        console.error('‚ùå Booking failed:', result.message);
        console.error('‚ùå Full booking response:', result);
        return { success: false, message: result.message };
      }
    } catch (error) {
      console.error('üí• Error creating booking:', error);
      console.error('üí• Error stack:', error.stack);
      return { success: false, message: error.message };
    }
  };
    }
  };

  // Ph∆∞∆°ng th·ª©c reset l·∫°i qu√° tr√¨nh booking
  const resetBooking = () => {
    setBookingState({
      serviceType: null,
      packageDuration: null,
      date: null,
      selectedSeat: null,
      paymentMethod: null,
      bookingComplete: false,
      seats: sampleSeats,
      paymentDetails: {
        totalAmount: 0,
        discount: 0,
        finalAmount: 0
      }
    });
    setCurrentStep(1);
  };

  // Ki·ªÉm tra xem c√≥ th·ªÉ ti·∫øp t·ª•c b∆∞·ªõc ti·∫øp theo kh√¥ng
  const canProceed = () => {
    switch (currentStep) {
      case 1:
        return !!bookingState.serviceType;
      case 2:
        return !!bookingState.packageDuration;
      case 3:
        return !!bookingState.date;
      case 4:
        return !!bookingState.selectedSeat;
      case 5:
        return !!bookingState.paymentMethod; // C·∫ßn ch·ªçn ph∆∞∆°ng th·ª©c thanh to√°n ƒë·ªÉ x√°c nh·∫≠n
      default:
        return false;
    }
  };

  // Ph∆∞∆°ng th·ª©c l·∫•y occupied seats t·ª´ API
  const fetchOccupiedSeats = async (serviceType, date, startTime, endTime) => {
    if (!serviceType || !date) return;

    setLoading(true);
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        console.error('No authentication token found');
        throw new Error('No authentication token found');
      }

  const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';
      let url = `${apiUrl}/api/bookings/seats/occupied?serviceType=${serviceType}&date=${date}`;
      if (startTime) url += `&startTime=${startTime}`;
      if (endTime) url += `&endTime=${endTime}`;

      console.log('üîç Fetching occupied seats:', { serviceType, date, startTime, endTime, url });

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`HTTP error! status: ${response.status}, response: ${errorText}`);
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      console.log('üìä Occupied seats response:', data);
      console.log('üìä Occupied seats response:', data);
      setOccupiedSeats(data.occupiedSeats || []);
      
      // Force re-render by updating the state
      setBookingState(prev => ({
        ...prev,
        lastUpdated: Date.now() // Add timestamp to force re-render
      }));

    } catch (error) {
      console.error('‚ùå Error fetching occupied seats:', error);
      // In tr∆∞·ªùng h·ª£p l·ªói, v·∫´n c·ªë g·∫Øng load d·ªØ li·ªáu m·∫´u
      console.log('‚ö†Ô∏è Using sample seat data due to API error');
    } finally {
      setLoading(false);
    }
  };

  // Ph∆∞∆°ng th·ª©c ki·ªÉm tra xem seat c√≥ b·ªã occupied kh√¥ng
  const isSeatOccupied = (seatId) => {
    return occupiedSeats.some(occupied => occupied.seatId === seatId);
  };

  // Force refresh occupied seats (clear cache and refetch)
  const forceRefreshOccupiedSeats = async () => {
    if (!bookingState.serviceType || !bookingState.date) return;
    
    console.log('üîÑ Force refreshing occupied seats...');
    setLoading(true);
    
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        console.error('No authentication token found');
        return;
      }

      // Add timestamp to prevent caching
  const apiUrl = process.env.REACT_APP_API_URL || 'http://localhost:5000';
      let url = `${apiUrl}/api/bookings/seats/occupied?serviceType=${bookingState.serviceType}&date=${bookingState.date}&t=${Date.now()}`;
      if (bookingState.time) url += `&startTime=${bookingState.time}`;
      if (bookingState.endTime) url += `&endTime=${bookingState.endTime}`;

      console.log('üîç Force refresh URL:', url);

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache', // Prevent browser caching
          'Pragma': 'no-cache'
        }
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`HTTP error! status: ${response.status}, response: ${errorText}`);
        return;
      }

      const data = await response.json();
      console.log('üìä Force refresh response:', data);
      
      // Clear old state and set new data
      setOccupiedSeats([]);
      setTimeout(() => {
        setOccupiedSeats(data.occupiedSeats || []);
        console.log('‚úÖ Occupied seats updated:', data.occupiedSeats?.length || 0);
      }, 100);
      
      // Force re-render by updating timestamp
      setBookingState(prev => ({
        ...prev,
        lastUpdated: Date.now()
      }));

    } catch (error) {
      console.error('‚ùå Error force refreshing occupied seats:', error);
    } finally {
      setLoading(false);
    }
  };

  // Gi√° tr·ªã cung c·∫•p cho context
  const value = {
    bookingState,
    currentStep,
    setCurrentStep,
    selectServiceType,
    selectPackageDuration,
    // expose ƒë·ªÉ trang Duration g·ªçi ƒë·∫£m b·∫£o ƒë√£ load packages
    ensurePackagesLoaded: fetchPackagesIfNeeded,
    selectDate,
    selectSeat,
    selectPaymentMethod,
    confirmBooking,
    resetBooking,
    canProceed,
    occupiedSeats,
    loading,
    fetchOccupiedSeats,
    forceRefreshOccupiedSeats,
    isSeatOccupied
  };

  return (
    <BookingContext.Provider value={value}>
      {children}
    </BookingContext.Provider>
  );
};

// Hook t√πy ch·ªânh ƒë·ªÉ s·ª≠ d·ª•ng BookingContext
export const useBooking = () => {
  return useContext(BookingContext);
};
