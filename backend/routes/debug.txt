error:UnicodeDecodeError('charmap', b'const express = require(\'express\');\r\nconst router = express.Router();\r\nconst db = require(\'../config/database\');\r\nconst path = require(\'path\');\r\nconst fs = require(\'fs\');\r\nconst { spawn, exec } = require(\'child_process\');\r\nconst multer = require(\'multer\');\r\nconst { verifyToken, requireAdmin } = require(\'../middleware/authMiddleware\');\r\n\r\n// ============== In-memory AI state for Floor 1 (demo/stub) ==============\r\nlet floor1AI = {\r\n  active: false,\r\n  peopleCount: 0,\r\n  lastUpdate: null\r\n};\r\nlet floor1Activities = []; // {message, at}\r\nconst sseClients = new Set();\r\nlet workerProc = null; // spawned YOLOv8 sender process\r\nconst videoPersistPath = path.resolve(__dirname, \'..\', \'ai\', \'yolov8\', \'floor1_video_source.txt\');\r\nlet floor1VideoSource = null; // absolute path of uploaded video (fixed desk)\r\nfloor1VideoSource = loadPersistedVideoSource();\r\n\r\n// Separate state for Hot Desk\r\nlet floor1HD = {\r\n  active: false,\r\n  peopleCount: 0,\r\n  lastUpdate: null\r\n};\r\nlet floor1HDActivities = []; // {message, at}\r\nconst sseClientsHD = new Set();\r\nlet workerProcHD = null;\r\n\r\nfunction getYoloPaths() {\r\n  const yoloDir = path.resolve(__dirname, \'..\', \'ai\', \'yolov8\');\r\n  const venvPy = path.join(yoloDir, \'.venv\', \'Scripts\', \'python.exe\');\r\n  const sender = path.join(yoloDir, \'sender.py\');\r\n  return { yoloDir, venvPy, sender };\r\n}\r\n\r\nfunction loadPersistedVideoSource() {\r\n  try {\r\n    if (!fs.existsSync(videoPersistPath)) return null;\r\n    const raw = fs.readFileSync(videoPersistPath, \'utf8\').trim();\r\n    if (!raw) return null;\r\n    return fs.existsSync(raw) ? raw : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction persistVideoSource(filePath) {\r\n  try {\r\n    if (!filePath) {\r\n      if (fs.existsSync(videoPersistPath)) fs.unlinkSync(videoPersistPath);\r\n    } else {\r\n      fs.writeFileSync(videoPersistPath, filePath, \'utf8\');\r\n    }\r\n  } catch {\r\n    /* ignore */\r\n  }\r\n}\r\n\r\nfunction resolveCurrentVideoSource() {\r\n  if (floor1VideoSource && fs.existsSync(floor1VideoSource)) return floor1VideoSource;\r\n  const persisted = loadPersistedVideoSource();\r\n  if (persisted) {\r\n    floor1VideoSource = persisted;\r\n    return floor1VideoSource;\r\n  }\r\n  floor1VideoSource = null;\r\n  return null;\r\n}\r\n\r\nfunction startWorkerIfNeeded() {\r\n  if (workerProc) return { started: false, pid: workerProc.pid };\r\n  const { yoloDir, venvPy, sender } = getYoloPaths();\r\n  const pythonExe = fs.existsSync(venvPy) ? venvPy : \'python\';\r\n  if (!fs.existsSync(sender)) return { started: false, error: \'sender.py not found\' };\r\n  const backendUrl = process.env.SWSPACE_BACKEND_URL || \'http://localhost:5000\';\r\n  const userVideo = resolveCurrentVideoSource();\r\n  if (!userVideo) {\r\n    return { started: false, error: \'upload-required\' };\r\n  }\r\n  const sourceArg = userVideo;\r\n  const seatZones = path.join(yoloDir, \'seat_zones_floor1.json\');\r\n  const args = [\r\n    sender,\r\n    \'--backend\', backendUrl,\r\n    \'--namespace\', \'ai\',\r\n    \'--source\', sourceArg,\r\n    \'--classes\', \'0\',\r\n    \'--conf\', \'0.40\',\r\n    \'--min-area\', \'0.003\',\r\n    \'--face-verify\', \'1\',\r\n    \'--ar-thresh\', \'0.8\',\r\n    \'--draw-boxes\', \'0\',\r\n    \'--max-dim\', \'960\',\r\n    \'--jpeg-quality\', \'60\',\r\n    \'--imgsz\', \'960\',\r\n    \'--iou\', \'0.55\',\r\n    \'--post-interval\', \'0.6\',\r\n    \'--stream-max-dim\', \'720\'\r\n  ];\r\n  if (fs.existsSync(seatZones)) {\r\n    args.push(\'--seat-zones\', seatZones);\r\n  }\r\n  try {\r\n    const child = spawn(pythonExe, args, { cwd: yoloDir, stdio: [\'ignore\', \'ignore\', \'ignore\'] });\r\n    workerProc = child;\r\n    child.on(\'exit\', () => { workerProc = null; });\r\n    return { started: true, pid: child.pid };\r\n  } catch (e) {\r\n    return { started: false, error: e.message };\r\n  }\r\n}\r\n\r\nfunction startWorkerHDIfNeeded() {\r\n  if (workerProcHD) return { started: false, pid: workerProcHD.pid };\r\n  const { yoloDir, venvPy, sender } = getYoloPaths();\r\n  const pythonExe = fs.existsSync(venvPy) ? venvPy : \'python\';\r\n  if (!fs.existsSync(sender)) return { started: false, error: \'sender.py not found\' };\r\n  const backendUrl = process.env.SWSPACE_BACKEND_URL || \'http://localhost:5000\';\r\n  // Hot Desk default is laptop webcam (0); allow override via SWSPACE_F1_HD_SOURCE\r\n  const demoVideo = path.resolve(__dirname, \'..\', \'video_demo.mp4\');\r\n  const sourceArg = process.env.SWSPACE_F1_HD_SOURCE || \'0\';\r\n    const args = [\r\n      sender,\r\n      \'--backend\', backendUrl,\r\n      \'--namespace\', \'ai-hd\',\r\n      \'--source\', sourceArg,\r\n      \'--classes\', \'0\',\r\n      \'--conf\', \'0.55\',\r\n      \'--min-area\', \'0.004\',\r\n      \'--face-verify\', \'1\',\r\n      \'--ar-thresh\', \'0.8\',\r\n      \'--draw-boxes\', \'1\',\r\n      \'--max-dim\', \'640\',\r\n      \'--jpeg-quality\', \'45\'       // hot desk c\xe1\xba\xa7n nhanh h\xc6\xa1n -> 45\r\n    ];\r\n    if (process.env.SWSPACE_STRICT_HUMAN !== \'0\') {\r\n      args.push(\'--min-area\', \'0.004\');\r\n    }\r\n  // No seat zones for HD by default\r\n  try {\r\n    const child = spawn(pythonExe, args, { cwd: yoloDir, stdio: [\'ignore\', \'ignore\', \'ignore\'] });\r\n    workerProcHD = child;\r\n    child.on(\'exit\', () => { workerProcHD = null; });\r\n    return { started: true, pid: child.pid };\r\n  } catch (e) {\r\n    return { started: false, error: e.message };\r\n  }\r\n}\r\n\r\nfunction stopWorkerIfRunning() {\r\n  if (!workerProc) return { stopped: false };\r\n  const pid = workerProc.pid;\r\n  try {\r\n    if (process.platform === \'win32\') {\r\n      exec(`taskkill /PID ${pid} /T /F`, () => {});\r\n    } else {\r\n      workerProc.kill(\'SIGTERM\');\r\n    }\r\n  } catch {}\r\n  workerProc = null;\r\n  return { stopped: true, pid };\r\n}\r\n\r\nfunction stopWorkerHDIfRunning() {\r\n  if (!workerProcHD) return { stopped: false };\r\n  const pid = workerProcHD.pid;\r\n  try {\r\n    if (process.platform === \'win32\') {\r\n      exec(`taskkill /PID ${pid} /T /F`, () => {});\r\n    } else {\r\n      workerProcHD.kill(\'SIGTERM\');\r\n    }\r\n  } catch {}\r\n  workerProcHD = null;\r\n  return { stopped: true, pid };\r\n}\r\n\r\nfunction sseBroadcast(event, data) {\r\n  const payload = `event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`;\r\n  for (const res of sseClients) {\r\n    try { res.write(payload); } catch { /* ignore broken pipe */ }\r\n  }\r\n}\r\n\r\nfunction sseBroadcastHD(event, data) {\r\n  const payload = `event: ${event}\\ndata: ${JSON.stringify(data)}\\n\\n`;\r\n  for (const res of sseClientsHD) {\r\n    try { res.write(payload); } catch {}\r\n  }\r\n}\r\nfunction pushActivity(arr, message, at, broadcastFn) {\r\n  if (!message) return;\r\n  arr.unshift({ message, at });\r\n  if (arr.length > 50) arr.pop();\r\n  broadcastFn(\'ai.activity\', { message, at });\r\n}\r\n\r\n// Map DB enum -> UI\r\nconst toUI = (dbStatus) => {\r\n  switch (dbStatus) {\r\n    case \'available\': return \'Available\';\r\n    case \'occupied\': return \'Occupied\';\r\n    case \'reserved\': return \'Reserved\';\r\n    case \'disabled\': return \'Maintenance\';\r\n    default: return \'Available\';\r\n  }\r\n};\r\n\r\n// Map UI -> DB enum\r\nconst toDB = (uiStatus) => {\r\n  switch (uiStatus) {\r\n    case \'Available\': return \'available\';\r\n    case \'Occupied\': return \'occupied\';\r\n    case \'Reserved\': return \'reserved\';\r\n    case \'Maintenance\': return \'disabled\';\r\n    default: return \'available\';\r\n  }\r\n};\r\n\r\nasync function getFloor1FixedDeskZoneIds() {\r\n  const sql = `\r\n    SELECT z.id AS zone_id, z.name AS zone_name\r\n    FROM zones z\r\n    JOIN floors f ON z.floor_id = f.id\r\n    JOIN services s ON z.service_id = s.id\r\n    WHERE f.code = \'F1\' AND s.code = \'fixed_desk\'\r\n  `;\r\n  const { rows } = await db.query(sql);\r\n  return rows;\r\n}\r\n\r\nasync function getFloor1HotDeskZoneIds() {\r\n  const sql = `\r\n    SELECT z.id AS zone_id, z.name AS zone_name\r\n    FROM zones z\r\n    JOIN floors f ON z.floor_id = f.id\r\n    JOIN services s ON z.service_id = s.id\r\n    WHERE f.code = \'F1\' AND s.code = \'hot_desk\'\r\n  `;\r\n  const { rows } = await db.query(sql);\r\n  return rows;\r\n}\r\n\r\n// GET fixed desks\r\n// List all Fixed Desk seats (admin + user)\r\nrouter.get(\'/fixed-desks\', async (req, res, next) => {\r\n  try {\r\n    const zones = await getFloor1FixedDeskZoneIds();\r\n    if (!zones.length) return res.json([]);\r\n    const zoneIds = zones.map(z => z.zone_id);\r\n    const { rows } = await db.query(\r\n      `SELECT s.seat_code, s.status, s.pos_x, s.pos_y, s.capacity, z.name AS zone\r\n       FROM seats s\r\n       JOIN zones z ON s.zone_id = z.id\r\n       WHERE s.zone_id = ANY($1::bigint[]) \r\n       ORDER BY s.seat_code`,\r\n      [zoneIds]\r\n    );\r\n    const data = rows.map(r => ({\r\n      seatCode: r.seat_code,\r\n      zone: r.zone,\r\n      status: toUI(r.status),\r\n      posX: r.pos_x,\r\n      posY: r.pos_y,\r\n      capacity: r.capacity\r\n    }));\r\n    res.json(data);\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// Update seat status\r\nrouter.post(\'/fixed-desks/:seatCode/status\', verifyToken, requireAdmin, async (req, res, next) => {\r\n  try {\r\n    const { seatCode } = req.params;\r\n    const { status } = req.body || {};\r\n    if (!seatCode || !status) return res.status(400).json({ error: \'seatCode and status are required\' });\r\n    const dbStatus = toDB(status);\r\n    const { rowCount } = await db.query(\r\n      \'UPDATE seats SET status = $1 WHERE seat_code = $2\',\r\n      [dbStatus, seatCode]\r\n    );\r\n    if (!rowCount) return res.status(404).json({ error: \'Seat not found\' });\r\n    res.json({ seatCode, status });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// AI status endpoints\r\nrouter.get(\'/ai/status\', async (req, res, next) => {\r\n  try {\r\n    const { rows: floors } = await db.query(\'SELECT id FROM floors WHERE code = $1 LIMIT 1\', [\'F1\']);\r\n    if (!floors.length) return res.json({ peopleCount: 0, lastUpdate: null });\r\n    const floorId = floors[0].id;\r\n    const { rows } = await db.query(\r\n      `SELECT people_count, detected_at \r\n       FROM occupancy_events \r\n       WHERE floor_id = $1 \r\n       ORDER BY detected_at DESC \r\n       LIMIT 1`,\r\n      [floorId]\r\n    );\r\n    if (!rows.length) return res.json({ peopleCount: floor1AI.peopleCount || 0, lastUpdate: floor1AI.lastUpdate });\r\n    return res.json({ peopleCount: rows[0].people_count, lastUpdate: rows[0].detected_at });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\nrouter.post(\'/ai/status\', async (req, res, next) => {\r\n  try {\r\n    const { peopleCount, cameraId = null, modelVersion = null, extra = null, boxes = null, frame = null } = req.body || {};\r\n    if (typeof peopleCount !== \'number\') return res.status(400).json({ error: \'peopleCount (number) is required\' });\r\n    const { rows: floors } = await db.query(\'SELECT id FROM floors WHERE code = $1 LIMIT 1\', [\'F1\']);\r\n    if (!floors.length) return res.status(400).json({ error: \'Floor F1 not found\' });\r\n    const floorId = floors[0].id;\r\n    const { rows } = await db.query(\r\n      `INSERT INTO occupancy_events (camera_id, floor_id, zone_id, people_count, model_version, extra)\r\n       VALUES ($1, $2, NULL, $3, $4, $5)\r\n       RETURNING id, detected_at`,\r\n      [cameraId, floorId, peopleCount, modelVersion, extra]\r\n    );\r\n    const detectedAt = rows[0].detected_at;\r\n    // update in-memory and broadcast if active\r\n    const prev = floor1AI.peopleCount;\r\n    floor1AI.peopleCount = peopleCount;\r\n    floor1AI.lastUpdate = detectedAt;\r\n    if (floor1AI.active) sseBroadcast(\'ai.people\', { peopleCount, detectedAt, boxes, frame });\r\n    if (peopleCount > 0) {\r\n      pushActivity(floor1Activities, `People detected: ${peopleCount}`, detectedAt, sseBroadcast);\r\n    } else if (prev > 0 && peopleCount === 0) {\r\n      pushActivity(floor1Activities, \'Floor 1 is now empty\', detectedAt, sseBroadcast);\r\n    }\r\n    res.json({ id: rows[0].id, detectedAt, boxes, frame });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// Receive per-seat occupancy events from YOLO worker and broadcast to SSE\r\nrouter.post(\'/ai/seat\', (req, res) => {\r\n  const { seatCode, occupied, detectedAt = new Date().toISOString() } = req.body || {};\r\n  if (!seatCode || typeof occupied !== \'boolean\') return res.status(400).json({ error: \'seatCode (string) and occupied (boolean) are required\' });\r\n  if (floor1AI.active) sseBroadcast(\'ai.seat\', { seatCode, occupied, detectedAt });\r\n  res.json({ ok: true });\r\n});\r\n\r\n// ---------- Hot Desk AI (separate namespace ai-hd) ----------\r\nrouter.get(\'/ai-hd/status\', (req, res) => {\r\n  res.json({ peopleCount: floor1HD.peopleCount || 0, lastUpdate: floor1HD.lastUpdate });\r\n});\r\n\r\nrouter.post(\'/ai-hd/status\', (req, res) => {\r\n  const { peopleCount, boxes = null, frame = null } = req.body || {};\r\n  if (typeof peopleCount !== \'number\') return res.status(400).json({ error: \'peopleCount (number) is required\' });\r\n  const detectedAt = new Date().toISOString();\r\n  const prev = floor1HD.peopleCount;\r\n  floor1HD.peopleCount = peopleCount;\r\n  floor1HD.lastUpdate = detectedAt;\r\n  if (floor1HD.active) sseBroadcastHD(\'ai.people\', { peopleCount, detectedAt, boxes, frame });\r\n  if (peopleCount > 0) {\r\n    pushActivity(floor1HDActivities, `People detected: ${peopleCount}`, detectedAt, sseBroadcastHD);\r\n  } else if (prev > 0 && peopleCount === 0) {\r\n    pushActivity(floor1HDActivities, \'Hot Desk Floor 1 is now empty\', detectedAt, sseBroadcastHD);\r\n  }\r\n  res.json({ ok: true, detectedAt, boxes, frame });\r\n});\r\n\r\nrouter.get(\'/ai-hd/control\', (req, res) => {\r\n  res.json({ active: floor1HD.active });\r\n});\r\n\r\nrouter.post(\'/ai-hd/control\', verifyToken, requireAdmin, (req, res) => {\r\n  const { active } = req.body || {};\r\n  const next = !!active;\r\n  if (next && !floor1HD.active) {\r\n    startWorkerHDIfNeeded();\r\n  } else if (!next && floor1HD.active) {\r\n    stopWorkerHDIfRunning();\r\n    floor1HD.peopleCount = 0;\r\n    floor1HD.lastUpdate = null;\r\n  }\r\n  floor1HD.active = next;\r\n  sseBroadcastHD(\'ai.control\', { active: floor1HD.active });\r\n  res.json({ active: floor1HD.active });\r\n});\r\n\r\nrouter.get(\'/ai-hd/stream\', (req, res) => {\r\n  res.setHeader(\'Content-Type\', \'text/event-stream\');\r\n  res.setHeader(\'Cache-Control\', \'no-cache\');\r\n  res.setHeader(\'Connection\', \'keep-alive\');\r\n  res.flushHeaders && res.flushHeaders();\r\n  res.write(`event: ai.hello\\ndata: {"ok":true}\\n\\n`);\r\n  sseClientsHD.add(res);\r\n  req.on(\'close\', () => {\r\n    sseClientsHD.delete(res);\r\n  });\r\n});\r\n\r\n// Activities endpoints (recent AI events)\r\nrouter.get(\'/ai/activities\', (req, res) => {\r\n  res.json({ items: floor1Activities });\r\n});\r\nrouter.get(\'/ai-hd/activities\', (req, res) => {\r\n  res.json({ items: floor1HDActivities });\r\n});\r\n\r\n// ---------- Hot Desk occupancy by datetime ----------\r\nrouter.get(\'/hot-desk/occupancy\', async (req, res, next) => {\r\n  try {\r\n    const atParam = req.query.at;\r\n    const at = atParam ? new Date(atParam) : new Date();\r\n    if (isNaN(at.getTime())) return res.status(400).json({ error: \'invalid at datetime\' });\r\n\r\n    const zones = await getFloor1HotDeskZoneIds();\r\n    if (!zones.length) {\r\n      // Fallback: if no zones, return zeros with total seats default 110 (project config)\r\n      const totalSeats = 110;\r\n      return res.json({\r\n        at: at.toISOString(),\r\n        breakdown: { day: 0, week: 0, month: 0, year: 0 },\r\n        totals: { totalSeats, booked: 0, available: totalSeats, occupancyRate: 0 }\r\n      });\r\n    }\r\n    const zoneIds = zones.map(z => z.zone_id);\r\n\r\n    // Total seats\r\n    const { rows: seatRows } = await db.query(\r\n      `SELECT COUNT(*)::int AS total FROM seats WHERE zone_id = ANY($1::bigint[])`,\r\n      [zoneIds]\r\n    );\r\n    const totalSeats = seatRows.length ? seatRows[0].total : 110;\r\n\r\n    // Active bookings per package at time \'at\'\r\n    const { rows } = await db.query(\r\n      `WITH hot_seats AS (\r\n         SELECT id FROM seats WHERE zone_id = ANY($1::bigint[])\r\n       )\r\n       SELECT \r\n         COUNT(*) FILTER (\r\n           WHERE sp.code = \'day\' \r\n             AND b.start_time <= $2 \r\n             AND b.start_time + INTERVAL \'24 hours\' > $2\r\n         )::int AS day_active,\r\n         COUNT(*) FILTER (\r\n           WHERE sp.code = \'week\'\r\n             AND b.start_time <= $2 \r\n             AND b.start_time + INTERVAL \'7 days\' > $2\r\n         )::int AS week_active,\r\n         COUNT(*) FILTER (\r\n           WHERE sp.code = \'month\'\r\n             AND b.start_time <= $2 \r\n             AND b.start_time + INTERVAL \'30 days\' > $2\r\n         )::int AS month_active,\r\n         COUNT(*) FILTER (\r\n           WHERE sp.code = \'year\'\r\n             AND b.start_time <= $2 \r\n             AND b.start_time + INTERVAL \'365 days\' > $2\r\n         )::int AS year_active\r\n       FROM bookings b\r\n       JOIN hot_seats s ON s.id = b.seat_id\r\n       JOIN service_packages sp ON sp.id = b.package_id`,\r\n      [zoneIds, at.toISOString()]\r\n    );\r\n    const r = rows[0] || { day_active: 0, week_active: 0, month_active: 0, year_active: 0 };\r\n    const day = r.day_active|0, week = r.week_active|0, month = r.month_active|0, year = r.year_active|0;\r\n    const booked = day + week + month + year;\r\n    const available = Math.max(0, totalSeats - booked);\r\n    const occupancyRate = totalSeats ? Math.round((booked / totalSeats) * 100) : 0;\r\n\r\n    res.json({\r\n      at: at.toISOString(),\r\n      breakdown: { day, week, month, year },\r\n      totals: { totalSeats, booked, available, occupancyRate }\r\n    });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// Control AI active/pause for Floor 1\r\nrouter.get(\'/ai/control\', (req, res) => {\r\n  res.json({ active: floor1AI.active });\r\n});\r\n\r\nrouter.post(\'/ai/control\', verifyToken, requireAdmin, (req, res) => {\r\n  const { active } = req.body || {};\r\n  const next = !!active;\r\n  // start/stop local YOLO worker automatically (scoped to Floor 1 only)\r\n  if (next && !floor1AI.active) {\r\n    const result = startWorkerIfNeeded();\r\n    if (result && result.error) {\r\n      const status = result.error === \'upload-required\' ? 400 : 500;\r\n      const message = result.error === \'upload-required\' ? \'Upload a video before activating AI detection.\' : result.error;\r\n      return res.status(status).json({ error: message });\r\n    }\r\n  } else if (!next && floor1AI.active) {\r\n    stopWorkerIfRunning();\r\n    // also reset last known numbers so UI shows clean state\r\n    floor1AI.peopleCount = 0;\r\n    floor1AI.lastUpdate = null;\r\n  }\r\n  floor1AI.active = next;\r\n  // notify clients about control change\r\n  sseBroadcast(\'ai.control\', { active: floor1AI.active });\r\n  res.json({ active: floor1AI.active });\r\n});\r\n\r\n// SSE stream for real-time AI updates\r\nrouter.get(\'/ai/stream\', (req, res) => {\r\n  res.setHeader(\'Content-Type\', \'text/event-stream\');\r\n  res.setHeader(\'Cache-Control\', \'no-cache\');\r\n  res.setHeader(\'Connection\', \'keep-alive\');\r\n  res.flushHeaders && res.flushHeaders();\r\n  res.write(`event: ai.hello\\ndata: {"ok":true}\\n\\n`);\r\n  sseClients.add(res);\r\n  req.on(\'close\', () => {\r\n    sseClients.delete(res);\r\n  });\r\n});\r\n\r\n// Seat details (for admin panel): include current/nearest booking and user info\r\n// Seat detail for admin panel\r\nrouter.get(\'/fixed-desks/:seatCode/detail\', async (req, res, next) => {\r\n  try {\r\n    const { seatCode } = req.params;\r\n    if (!seatCode) return res.status(400).json({ error: \'seatCode is required\' });\r\n    const { rows } = await db.query(\r\n      `WITH seat_row AS (\r\n         SELECT s.id, s.seat_code, s.status, s.pos_x, s.pos_y, s.capacity, z.name AS zone\r\n         FROM seats s\r\n         JOIN zones z ON z.id = s.zone_id\r\n         WHERE s.seat_code = $1\r\n       ), latest_booking AS (\r\n         SELECT b.*\r\n         FROM bookings b\r\n         JOIN seat_row sr ON sr.id = b.seat_id\r\n         WHERE b.end_time >= NOW() -- c\xc3\xb2n hi\xe1\xbb\x87u l\xe1\xbb\xb1c ho\xe1\xba\xb7c t\xc6\xb0\xc6\xa1ng lai g\xe1\xba\xa7n\r\n         ORDER BY b.updated_at DESC NULLS LAST\r\n         LIMIT 1\r\n       ), pay AS (\r\n         SELECT p.*\r\n         FROM payments p\r\n         JOIN latest_booking b ON b.id = p.booking_id\r\n         ORDER BY p.updated_at DESC NULLS LAST\r\n         LIMIT 1\r\n       )\r\n       SELECT sr.seat_code, sr.zone, sr.status AS seat_status, sr.pos_x, sr.pos_y,\r\n              sr.capacity,\r\n              b.id AS booking_id, b.start_time, b.end_time, b.status AS booking_status,\r\n              u.id AS user_id, u.full_name, u.email, u.phone,\r\n              sp.name AS package_name,\r\n              pay.status AS payment_status\r\n       FROM seat_row sr\r\n       LEFT JOIN latest_booking b ON TRUE\r\n       LEFT JOIN users u ON u.id = b.user_id\r\n       LEFT JOIN service_packages sp ON sp.id = b.package_id\r\n       LEFT JOIN pay ON TRUE`,\r\n      [seatCode]\r\n    );\r\n\r\n    if (!rows.length) return res.status(404).json({ error: \'Seat not found\' });\r\n    const r = rows[0];\r\n    const paymentUI = (() => {\r\n      switch (r.payment_status) {\r\n        case \'success\': return \'Paid\';\r\n        case \'failed\':\r\n        case \'expired\': return \'Overdue\';\r\n        case \'processing\':\r\n        case \'created\':\r\n        default: return r.booking_id ? \'Pending\' : null;\r\n      }\r\n    })();\r\n    const data = {\r\n      seatCode: r.seat_code,\r\n      zone: r.zone,\r\n      status: toUI(r.seat_status),\r\n      posX: r.pos_x,\r\n      posY: r.pos_y,\r\n      capacity: r.capacity,\r\n      user: r.user_id ? {\r\n        id: r.user_id,\r\n        name: r.full_name,\r\n        email: r.email,\r\n        phone: r.phone\r\n      } : null,\r\n      booking: r.booking_id ? {\r\n        id: r.booking_id,\r\n        package: r.package_name,\r\n        startDate: r.start_time,\r\n        endDate: r.end_time,\r\n        paymentStatus: paymentUI\r\n      } : null\r\n    };\r\n    res.json(data);\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// Availability for user frontend: block Maintenance and Occupied\r\nrouter.get(\'/fixed-desks/:seatCode/availability\', async (req, res, next) => {\r\n  try {\r\n    const { seatCode } = req.params;\r\n    const { rows } = await db.query(\r\n      `SELECT s.id, s.status FROM seats s WHERE s.seat_code = $1 LIMIT 1`,\r\n      [seatCode]\r\n    );\r\n    if (!rows.length) return res.status(404).json({ error: \'Seat not found\' });\r\n    const s = rows[0];\r\n    if (s.status === \'disabled\') return res.json({ seatCode, available: false, reason: \'maintenance\' });\r\n    if (s.status === \'occupied\' || s.status === \'reserved\') return res.json({ seatCode, available: false, reason: \'occupied\' });\r\n    return res.json({ seatCode, available: true });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// ----------------- CRUD: Create a new seat -----------------\r\nrouter.post(\'/fixed-desks\', verifyToken, requireAdmin, async (req, res, next) => {\r\n  try {\r\n    const { seatCode, capacity, zoneId } = req.body || {};\r\n    if (!seatCode) return res.status(400).json({ error: \'seatCode is required\' });\r\n    const cap = parseInt(capacity, 10);\r\n    if (Number.isNaN(cap) || cap <= 0) return res.status(400).json({ error: \'capacity must be a positive integer\' });\r\n    // Ensure unique seat code\r\n    const exists = await db.query(\'SELECT 1 FROM seats WHERE seat_code = $1 LIMIT 1\', [seatCode]);\r\n    if (exists.rowCount) return res.status(409).json({ error: \'Seat code already exists\' });\r\n    // Determine zone\r\n    const zones = await getFloor1FixedDeskZoneIds();\r\n    if (!zones.length) return res.status(400).json({ error: \'No Fixed Desk zones configured for Floor 1\' });\r\n    let targetZoneId = zoneId ? parseInt(zoneId, 10) : zones[0].zone_id;\r\n    if (!zones.some(z => z.zone_id === targetZoneId)) return res.status(400).json({ error: \'Invalid zoneId for Floor 1 Fixed Desk\' });\r\n    await db.query(\r\n      \'INSERT INTO seats (zone_id, seat_code, status, capacity) VALUES ($1, $2, $3, $4)\',\r\n      [targetZoneId, seatCode, \'available\', cap]\r\n    );\r\n    res.status(201).json({ seatCode, capacity: cap, zoneId: targetZoneId, status: \'Available\' });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// ----------------- CRUD: Update seat (rename / capacity) -----------------\r\nrouter.put(\'/fixed-desks/:seatCode\', verifyToken, requireAdmin, async (req, res, next) => {\r\n  try {\r\n    const { seatCode } = req.params;\r\n    const { newSeatCode, capacity } = req.body || {};\r\n    if (!seatCode) return res.status(400).json({ error: \'seatCode param required\' });\r\n    const cap = capacity !== undefined ? parseInt(capacity, 10) : undefined;\r\n    if (cap !== undefined && (Number.isNaN(cap) || cap <= 0)) return res.status(400).json({ error: \'capacity must be positive integer\' });\r\n    // Check existing seat\r\n    const seatRes = await db.query(\'SELECT id FROM seats WHERE seat_code = $1 LIMIT 1\', [seatCode]);\r\n    if (!seatRes.rowCount) return res.status(404).json({ error: \'Seat not found\' });\r\n    const updates = [];\r\n    const params = [];\r\n    let idx = 1;\r\n    if (newSeatCode && newSeatCode !== seatCode) {\r\n      const dup = await db.query(\'SELECT 1 FROM seats WHERE seat_code = $1 LIMIT 1\', [newSeatCode]);\r\n      if (dup.rowCount) return res.status(409).json({ error: \'newSeatCode already exists\' });\r\n      updates.push(`seat_code = $${idx++}`);\r\n      params.push(newSeatCode);\r\n    }\r\n    if (cap !== undefined) {\r\n      updates.push(`capacity = $${idx++}`);\r\n      params.push(cap);\r\n    }\r\n    if (!updates.length) return res.json({ seatCode, capacity: cap });\r\n    params.push(seatCode);\r\n    await db.query(`UPDATE seats SET ${updates.join(\', \')} WHERE seat_code = $${idx}`, params);\r\n    res.json({ seatCode: newSeatCode || seatCode, capacity: cap });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\n// ----------------- CRUD: Delete seat -----------------\r\nrouter.delete(\'/fixed-desks/:seatCode\', verifyToken, requireAdmin, async (req, res, next) => {\r\n  try {\r\n    const { seatCode } = req.params;\r\n    if (!seatCode) return res.status(400).json({ error: \'seatCode param required\' });\r\n    // Active bookings check\r\n    const active = await db.query(\r\n      `SELECT COUNT(*)::int AS cnt\r\n       FROM bookings b\r\n       JOIN seats s ON s.id = b.seat_id\r\n       WHERE s.seat_code = $1 AND b.end_time > NOW()`,\r\n      [seatCode]\r\n    );\r\n    if (active.rows[0].cnt > 0) return res.status(409).json({ error: \'Seat has active bookings; cannot delete\' });\r\n    const del = await db.query(\'DELETE FROM seats WHERE seat_code = $1\', [seatCode]);\r\n    if (!del.rowCount) return res.status(404).json({ error: \'Seat not found\' });\r\n    res.json({ deleted: true, seatCode });\r\n  } catch (e) { next(e); }\r\n});\r\n\r\nmodule.exports = router;\r\n\r\n// ================== Upload video & Seat Zones (Fixed Desk calibration) ==================\r\n// C\xe1\xba\xa5u h\xc3\xacnh l\xc6\xb0u file upload\r\nconst uploadsDir = path.resolve(__dirname, \'..\', \'uploads\');\r\nif (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });\r\nconst storage = multer.diskStorage({\r\n  destination: (req, file, cb) => cb(null, uploadsDir),\r\n  filename: (req, file, cb) => {\r\n    const ts = Date.now();\r\n    const safe = file.originalname.replace(/[^a-zA-Z0-9_.-]/g, \'_\');\r\n    cb(null, `${ts}_${safe}`);\r\n  }\r\n});\r\nconst upload = multer({ storage });\r\n\r\n// Upload MP4 video to be used as the YOLO source for the fixed desk camera\r\nrouter.post(\'/ai/upload-video\', verifyToken, requireAdmin, upload.single(\'video\'), (req, res) => {\r\n  if (!req.file) return res.status(400).json({ error: \'No video file uploaded\' });\r\n  // Only accept .mp4 for now\r\n  if (!/\\.mp4$/i.test(req.file.originalname)) {\r\n    return res.status(400).json({ error: \'Only .mp4 supported at the moment\' });\r\n  }\r\n  // Persist absolute path so the worker (running in another cwd) can open it\r\n  floor1VideoSource = path.resolve(req.file.path);\r\n  persistVideoSource(floor1VideoSource);\r\n  // If AI is currently active, stop the worker and signal clients to press Active again\r\n  if (floor1AI.active) {\r\n    try { stopWorkerIfRunning(); } catch {}\r\n    floor1AI.active = false;\r\n    floor1AI.peopleCount = 0;\r\n    floor1AI.lastUpdate = null;\r\n    sseBroadcast(\'ai.control\', { active: false });\r\n    sseBroadcast(\'ai.people\', { peopleCount: 0, detectedAt: new Date().toISOString(), boxes: [], frame: null });\r\n  }\r\n  res.json({ ok: true, filename: path.basename(req.file.path), url: `/uploads/${path.basename(req.file.path)}` });\r\n});\r\n\r\n// \xc4\x90\xe1\xbb\x8dc seat zones t\xe1\xbb\xab file JSON\r\nrouter.get(\'/ai/seat-zones\', (req, res) => {\r\n  try {\r\n    const { yoloDir } = getYoloPaths();\r\n    const filePath = path.join(yoloDir, \'seat_zones_floor1.json\');\r\n    if (!fs.existsSync(filePath)) return res.json({ items: [] });\r\n    const raw = fs.readFileSync(filePath, \'utf8\');\r\n    const items = JSON.parse(raw);\r\n    res.json({ items });\r\n  } catch (e) {\r\n    res.status(500).json({ error: \'Failed to read seat zones\', detail: e.message });\r\n  }\r\n});\r\n\r\n// L\xc6\xb0u / c\xe1\xba\xadp nh\xe1\xba\xadt m\xe1\xbb\x99t seat zone polygon (m\xe1\xba\xa3ng [ [x,y], ... ]) gi\xc3\xa1 tr\xe1\xbb\x8b \xc4\x91\xc3\xa3 \xc4\x91\xc6\xb0\xe1\xbb\xa3c chu\xe1\xba\xa9n ho\xc3\xa1 0..1\r\nrouter.post(\'/ai/seat-zones\', verifyToken, requireAdmin, (req, res) => {\r\n  const { seatCode, polygon } = req.body || {};\r\n  if (!seatCode || !Array.isArray(polygon)) {\r\n    return res.status(400).json({ error: \'seatCode v\xc3\xa0 polygon (m\xe1\xba\xa3ng) l\xc3\xa0 b\xe1\xba\xaft bu\xe1\xbb\x99c\' });\r\n  }\r\n  if (polygon.length > 0 && polygon.length < 3) {\r\n    return res.status(400).json({ error: \'Polygon c\xe1\xba\xa7n t\xe1\xbb\x91i thi\xe1\xbb\x83u 3 \xc4\x91i\xe1\xbb\x83m ho\xe1\xba\xb7c r\xe1\xbb\x97ng \xc4\x91\xe1\xbb\x83 xo\xc3\xa1 zone\' });\r\n  }\r\n  try {\r\n    const { yoloDir } = getYoloPaths();\r\n    const filePath = path.join(yoloDir, \'seat_zones_floor1.json\');\r\n    let items = [];\r\n    if (fs.existsSync(filePath)) {\r\n      items = JSON.parse(fs.readFileSync(filePath, \'utf8\'));\r\n    }\r\n    // lo\xe1\xba\xa1i b\xe1\xbb\x8f seatCode c\xc5\xa9 n\xe1\xba\xbfu t\xe1\xbb\x93n t\xe1\xba\xa1i\r\n    items = items.filter(z => z.seatCode !== seatCode);\r\n    if (polygon.length >= 3) {\r\n      items.push({ seatCode, polygon });\r\n    }\r\n    fs.writeFileSync(filePath, JSON.stringify(items, null, 2));\r\n    res.json({ ok: true, seatCode, polygon, removed: polygon.length === 0 });\r\n  } catch (e) {\r\n    res.status(500).json({ error: \'Failed to save seat zone\', detail: e.message });\r\n  }\r\n});\r\n\r\n', 27476, 27477, 'character maps to <undefined>')